<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APStat Chain</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsQR/1.4.0/jsQR.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #ffffff;
            color: #000000;
            transition: background-color 0.3s, color 0.3s;
            margin: 0;
            padding: 20px;
        }
        .dark {
            background-color: #1e1e1e;
            color: #ffffff;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }
        .questions-container {
            margin-top: 20px;
        }
        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
            margin: 20px 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        .dark th, .dark td {
            border-color: #444;
        }
        .volume-control {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        .volume-control input {
            margin: 0 10px;
        }
        .choice {
            margin: 10px 0;
        }
        .correct-choice {
            background-color: #d4edda;
        }
        .dark .correct-choice {
            background-color: #2b5329;
        }
        .reasoning, .solution {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ddd;
        }
        .dark .reasoning, .dark .solution {
            border-color: #444;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§® APStat Chain</h1>
        
        <div id="progress">Question 1 of 738</div>
        <div id="my-progress">My Progress: 0 Answered / 0 Mined</div>
        <div id="score">My Score: 0</div>
        <div id="class-average">Projected Class Average: 0</div>
        <div id="peers">Peers Seen: 0</div>
        
        <button id="themeToggle">Toggle Dark Mode</button>
        <button id="audioToggle">ðŸ”Š Audio On</button>
        <div class="volume-control">
            <p>ðŸ”Š Volume:</p>
            <input type="range" id="volumeSlider" min="0" max="100" value="70">
            <span id="volumeValue">70%</span>
        </div>
        
        <div id="messageContainer"></div>
        <div id="statsContainer"></div>
        <div id="questionsContainer"></div>
        <button id="submit-answer">Submit Answer</button>
        
        <nav>
            <button id="prev">Previous</button>
            <button id="next">Next</button>
        </nav>
        
        <div id="sync">
            <button id="generate-qr">Generate Sync QR</button>
            <div id="qr-code"></div>
            <button id="scan-qr">Scan Peer QR</button>
            <video id="video" style="display: none;"></video>
            <canvas id="canvas" style="display: none;"></canvas>
        </div>
    </div>

    <div id="contextFinder" class="context-finder" style="display:none;"></div>

    <script>
        // Fake curriculum for testing
        const POK_CURRICULUM = [
            {
                id: 1,
                prompt: 'What is the mean of 1, 2, 3?',
                attachments: {
                    choices: [{key: 'A', value: '1'}, {key: 'B', value: '2'}, {key: 'C', value: '3'}],
                    answerKey: 'B'
                },
                reasoning: 'The mean is (1+2+3)/3 = 2.',
                solution: 'Detailed calculation: sum = 6, n=3, mean=2.'
            },
            {
                id: 2,
                prompt: 'What is the median of 1, 2, 3?',
                attachments: {
                    choices: [{key: 'A', value: '1'}, {key: 'B', value: '2'}, {key: 'C', value: '3'}],
                    answerKey: 'B'
                },
                reasoning: 'Sorted: 1,2,3, median=2.'
            },
            {
                id: 3,
                prompt: 'Interpret this bar chart.',
                attachments: {
                    chartType: 'bar',
                    labels: ['A', 'B', 'C'],
                    series: [{ data: [10, 20, 30], backgroundColor: ['red', 'green', 'blue'] }]
                }
            },
            {
                id: 4,
                prompt: 'Interpret this scatter plot.',
                attachments: {
                    chartType: 'scatter',
                    series: [{ values: [[1,2], [3,4], [5,6]] }]  // Will be adapted to points
                }
            }
        ];

        var APStatChain = {
            questions: [],
            state: {
                currentIndex: 0,
                theme: 'light'
            },
            chartInstances: [],

            // Added hasUserAnswered as per fixes
            hasUserAnswered: function(questionId) {
                if (!this.state || !this.state.mempool || !this.state.identity) {
                    console.warn('hasUserAnswered called before state initialized');
                    return false;
                }
                
                const normalizedQuestionId = String(questionId);
                
                return this.state.mempool.some(tx => 
                    String(tx.questionId) === normalizedQuestionId && 
                    tx.ownerPubKey === this.state.identity.publicKey
                );
            },

            // Fake crypto for testing
            crypto: {
                generateMnemonic: function() {
                    return 'test mnemonic ' + Math.random().toString(36).substring(2);
                },
                deriveKeyPair: async function(mnemonic) {
                    // Fake key pair
                    return {
                        publicKey: 'pub_' + Math.random().toString(36).substring(2),
                        privateKey: 'priv_' + Math.random().toString(36).substring(2)
                    };
                }
            },

            renderer: {
                renderQuestion: function(question, index) {
                    // Deprecated, use renderCurrentQuestion
                },
                renderChart: function(attachment, containerId) {
                    if (typeof Chart === 'undefined') {
                        console.error('Chart.js library not loaded');
                        const container = document.getElementById(containerId);
                        if (container) {
                            container.outerHTML = '<div class="chart-error">Chart library failed to load. Please refresh the page.</div>';
                        }
                        return;
                    }
                    
                    setTimeout(() => {
                        const canvas = document.getElementById(containerId);
                        if (!canvas) {
                            console.error(`Canvas element ${containerId} not found`);
                            return;
                        }
                        
                        const ctx = canvas.getContext('2d');
                        let config = null;
                        
                        switch (attachment.chartType) {
                            case 'bar':
                            case 'histogram':
                                config = {
                                    type: attachment.chartType === 'histogram' ? 'bar' : 'bar', // Histogram as bar for simplicity
                                    data: {
                                        labels: attachment.labels || [],
                                        datasets: attachment.series || []
                                    },
                                    options: {
                                        scales: {
                                            x: { grid: { color: this.getGridColor() } },
                                            y: { grid: { color: this.getGridColor() } }
                                        },
                                        plugins: {
                                            legend: { labels: { color: this.getTextColor() } }
                                        },
                                        color: this.getTextColor()
                                    }
                                };
                                break;
                            case 'pie':
                                config = {
                                    type: 'pie',
                                    data: {
                                        labels: attachment.labels || [],
                                        datasets: [{
                                            data: attachment.values || [],
                                            backgroundColor: this.generateChartColors((attachment.values || []).length)
                                        }]
                                    },
                                    options: {
                                        plugins: {
                                            legend: { labels: { color: this.getTextColor() } }
                                        },
                                        color: this.getTextColor()
                                    }
                                };
                                break;
                            case 'scatter':
                                config = {
                                    type: 'scatter',
                                    data: {
                                        datasets: [{
                                            data: attachment.points || [],
                                            pointBackgroundColor: this.getScatterPointColor()
                                        }]
                                    },
                                    options: {
                                        scales: {
                                            x: { grid: { color: this.getGridColor() } },
                                            y: { grid: { color: this.getGridColor() } }
                                        },
                                        color: this.getTextColor()
                                    }
                                };
                                break;
                        }
                        
                        if (config) {
                            const chart = new Chart(ctx, config);
                            APStatChain.chartInstances.push(chart);
                        }
                    }, 0); // Use arrow function to preserve this
                },
                renderTable: function(tableData) {
                    if (!tableData || !Array.isArray(tableData.rows)) return '';
                    
                    let html = '<table>';
                    if (tableData.headers) {
                        html += '<thead><tr>' + tableData.headers.map(h => `<th>${h}</th>`).join('') + '</tr></thead>';
                    }
                    html += '<tbody>${tableData.rows.map(row => `<tr>${row.map(cell => `<td>${cell}</td>`).join('')}</tr>`).join('')}</tbody>';
                    html += '</table>';
                    return html;
                },
                renderChoices: function(choices, answerKey, questionId) {
                    if (!choices || !Array.isArray(choices)) return '';
                    
                    const isAnswered = APStatChain.hasUserAnswered(questionId);
                    const normalizedAnswer = (answerKey || '').toString().trim().toUpperCase();
                    
                    let html = '<div class="choices">';
                    choices.forEach(choice => {
                        const isCorrect = choice.key.toString().trim().toUpperCase() === normalizedAnswer;
                        const inputId = `choice-${choice.key}-${questionId}`;
                        const disabledAttr = isAnswered ? 'disabled' : '';
                        const correctClass = isCorrect && isAnswered ? 'correct-choice' : '';
                        
                        html += `
                            <div class="choice${correctClass}">
                                <label for="${inputId}">
                                    <input type="radio" name="answer" id="${inputId}" value="${choice.key}" ${disabledAttr}>
                                    <span class="choice-key"}>${choice.key}.</span>
                                    ${choice.value}
                                </label>
                            </div>
                        `;
                    }));
                    html += '</div>';
                    return html;
                },
                renderSolution: function(solution) {
                    return `<div class="solution"><strong>Solution:</strong> ${solution}</div>`;
                },
                forceChartRerender: function() {
                    APStatChain.chartInstances.forEach(chart => chart.destroy());
                    APStatChain.chartInstances = [];
                    this.initializeCharts(APStatChain.state.currentIndex);
                },
                generateChartColors: function(numColors) {
                    const colors = ['#ff6384', '#36a2eb', '#ffce56', '# etc.];
                    const darkColors = ['#cf3c4f', '#2270b5', '#c39300', etc.];
                    const base = APStatChain.ui.isDarkMode() ? darkColors : colors;
                    return Array.from({length: numColors}, (_, i) => base[i % base.length]);
                },
                getGridColor: function() {
                    return APStatChain.ui.isDarkMode() ? '#444444' : '#ddd';
                },
                getScatterPointColor: function() {
                    return APStatChain.ui.isDarkMode() ? '#ffffff' : '#000000';
                },
                getTextColor: function() {
                    return APStatChain.ui.isDarkMode() ? '#ffffff' : '#000000';
                },
                adaptQuestionFormat: function(pokQuestion) {
                    const adapted = JSON.parse(JSON.stringify(pokQuestion));
                    
                    if (pokQuestion.attachments) {
                        if (pokQuestion.attachments.chartType === 'dotplot' && 
                            pokQuestion.attachments.series && 
                            pokQuestion.attachments.series[0]) {
                            adapted.attachments.values = pokQuestion.attachments.series[0].values;
                        }
                        
                        if (pokQuestion.attachments.chartType === 'scatter' && 
                            pokQuestion.attachments.series && 
                            pokQuestion.attachments.series[0]) {
                            adapted.attachments.points = pokQuestion.attachments.series[0].values.map(
                                pair => ({ x: pair[0], y: pair[1] })
                            );
                        }
                        
                        if (pokQuestion.attachments.chartConfig && 
                            pokQuestion.attachments.chartConfig.yAxis) {
                            adapted.attachments.chartConfig.yAxis.hideTicks = 
                                adapted.attachments.chartConfig.yAxis.hideTicks || false;
                        }
                    }
                    
                    return adapted;
                },
                _generateQuestionHTML: function(adaptedQuestion, index) {
                    let html = `<div class="question">
                        <h2>Question ${index + 1}</h2>
                        <p>${adaptedQuestion.prompt || ''}</p>
                    `;
                    
                    if (adaptedQuestion.attachments) {
                        const att = adaptedQuestion.attachments;
                        if (att.chartType) {
                            html += `<div class="chart-container"><canvas id="chart-${adaptedQuestion.id}"></canvas></div>`;
                        }
                        if (att.table) {
                            html += this.renderTable(att.table);
                        }
                        if (att.choices) {
                            html += this.renderChoices(att.choices, att.answerKey, adaptedQuestion.id);
                        }
                    }
                    
                    if (adaptedQuestion.reasoning && APStatChain.hasUserAnswered(adaptedQuestion.id)) {
                        html += `
                            <div class="reasoning">
                                <strong>Explanation:</strong> ${adaptedQuestion.reasoning}
                            </div>
                        `;
                    }
                    
                    if (adaptedQuestion.solution && APStatChain.hasUserAnswered(adaptedQuestion.id)) {
                        html += this.renderSolution(adaptedQuestion.solution);
                    }
                    
                    html += `</div>`;
                    return html;
                },
                initializeCharts: function(index) {
                    const question = APStatChain.questions[index];
                    if (!question || !question.attachments) return;
                    
                    const att = question.attachments;
                    if (att.chartType) {
                        this.renderChart(att, `chart-${question.id}`);
                    }
                },
                renderCurrentQuestion: function() {
                    const index = this.state.currentIndex, question = this.questions[index];
                    if (!question) return;
                    
                    const adaptedQuestion = this.adaptQuestionFormat(question);
                    
                    const questionHTML = this._generateQuestionHTML(adaptedQuestion, index);
                    
                    document.getElementById('questionsContainer').innerHTML = questionHTML;
                    
                    // Post-render
                    if (typeof MathJax !== 'undefined') {
                        MathJax.typesetPromise().catch(err => console.error(err));
                    }
                    this.initializeCharts(index);
                    
                    // Update button states
                    const submitBtn = document.getElementById('submit-answer');
                    const isAnswered = APStatChain.hasUserAnswered(question.id);
                    submitBtn.disabled = isAnswered;
                    submitBtn.textContent = isAnswered ? 'Answered' : 'Submit Answer';
                    
                    APStatChain.ui.updateHUD();
                }
            },

            ui: {
                isDarkMode: function() {
                    return APStatChain.state.theme === 'dark';
                },
                toggleTheme: function() {
                    APStatChain.state.theme = APStatChain.state.theme === 'light' ? 'dark' : 'light';
                    document.body.classList.toggle('dark', APStatChain.ui.isDarkMode());
                    localStorage.setItem('APStatChainTheme', APStatChain.state.theme);
                    APStatChain.renderer.forceChartRerender();
                },
                updateHUD: function() {
                    const total = APStatChain.questions.length;
                    const current = APStatChain.state.currentIndex + 1;
                    document.getElementById('progress').innerHTML = `Question ${current} of ${total}`;
                    
                    const answered = APStatChain.state.mempool.length;
                    document.getElementById('my-progress').innerHTML = `My Progress: ${answered} Answered / 0} Mined`;
                    // TODO: Mined logic out of scope
                    
                    // Update nav buttons
                    document.getElementById('prev').disabled = (APStatChain.state.currentIndex === 0);
                    document.getElementById('next').disabled = (APStatChain.state.currentIndex >= total - 1) || !APStatChain.hasUserAnswered(APStatChain.questions[APStatChain.state.currentIndex].id);
                },
                bindNavEvents: function() {
                    document.getElementById('prev').addEventListener('click', async () => {
                        if (APStatChain.state.currentIndex > 0) {
                            APStatChain.state.currentIndex--;
                            APStatChain.renderer.renderCurrentQuestion();
                            await APStatChain.saveState();
                        }
                    });
                    
                    document.getElementById('next').addEventListener('click', async () => {
                        if (APStatChain.state.currentIndex < APStatChain.questions.length - 1 && APStatChain.hasUserAnswered(APStatChain.questions[APStatChain.state.currentIndex].id)) {
                            APStatChain.state.currentIndex++;
                            APStatChain.renderer.renderCurrentQuestion();
                            await APStatChain.saveState();
                        }
                    });
                    
                    document.getElementById('submit-answer').addEventListener('click', async () => {
                        const question = APStatChain.questions[APStatChain.state.currentIndex];
                        if (APStatChain.hasUserAnswered(question.id)) return;
                        
                        const selected = document.querySelector('input[name="answer"]:checked');
                        if (!selected) {
                            alert('Please select an answer');
                            return;
                        }
                        await APStatChain.mempool.createTransaction(question.id, selected.value);
                        APStatChain.renderer.renderCurrentQuestion();
                        await APStatChain.saveState();
                    });
                    
                    document.getElementById('themeToggle').addEventListener('click', () => {
                        APStatChain.ui.toggleTheme();
                    });
                    
                    document.getElementById('generate-qr').addEventListener('click', () => {
                        APStatChain.sync.generateQR();
                    });
                    
                    document.getElementById('scan-qr').addEventListener('click', () => {
                        APStatChain.sync.startScanner();
                    });
                    
                    document.getElementById('audioToggle').addEventListener('click', () => {
                        APStatChain.audio.enabled = !APStatChain.audio.enabled;
                        const btn = document.getElementById('audioToggle');
                        btn.textContent = APStatChain.audio.enabled ? 'ðŸ”Š Audio On' : 'ðŸ”ˆ Audio Off';
                    });
                    
                    document.getElementById('volumeSlider').addEventListener('input', (e) => {
                        const volume = e.target.value / 100;
                        if (APStatChain.audio.masterGain) {
                            APStatChain.audio.masterGain.gain.value = volume;
                        }
                        document.getElementById('volumeValue').textContent = `${e.target.value}%`;
                    });
                }
            },

            audio: {
                context: null,
                enabled: true,
                masterGain: null,
                playTone: function(frequency, duration) {
                    if (!this.enabled || !this.context) return;
                    const oscillator = this.context.createOscillator();
                    oscillator.frequency.value = frequency;
                    oscillator.connect(this.masterGain);
                    oscillator.start();
                    setTimeout(() => oscillator.stop(), duration);
                }
            },

            sync: {
                generateQR: function() {
                    const stateData = JSON.stringify(APStatChain.state);
                    new QRCode(document.getElementById('qr-code'), stateData);
                },
                startScanner: function() {
                    const video = document.getElementById('video');
                    navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } }).then(stream => {
                        video.srcObject = stream;
                        video.play();
                        const canvas = document.getElementById('canvas');
                        const ctx = canvas.getContext('2d');
                        const scan = () => {
                            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                                canvas.width = video.videoWidth;
                                canvas.height = video.videoHeight;
                                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                                const code = jsQR(imageData.data, imageData.width, imageData.height);
                                if (code) {
                                    console.log('Scanned:', code.data);
                                    stream.getTracks().forEach(track => track.stop());
                                    return;
                                }
                            }
                            requestAnimationFrame(scan);
                        };
                        scan();
                    }).catch(err => console.error(err));
                }
            },

            mempool: {
                createTransaction: async function(questionId, answer) {
                    const tx = {
                        questionId,
                        answer,
                        ownerPubKey: APStatChain.state.identity.publicKey,
                        timestamp: Date.now()
                    };
                    APStatChain.state.mempool.push(tx);
                    console.log('Transaction created:', tx);
                }
            },

            saveState: async function() {
                localStorage.setItem('APStatChainState', JSON.stringify(APStatChain.state));
            },

            init: async function() {
                try {
                    APStatChain.questions = POK_CURRICULUM;
                    
                    const savedState = localStorage.getItem('APStatChainState');
                    
                    if (savedState) {
                        this.state = JSON.parse(savedState);
                        
                        if (!this.state.identity || !this.state.identity.publicKey) {
                            throw new Error('Invalid saved state - missing identity');
                        }
                    } else {
                        console.log("Creating new user identity...");
                        const mnemonic = this.crypto.generateMnemonic();
                        const keyPair = await this.crypto.deriveKeyPair(mnemonic);
                        
                        if (!keyPair) {
                            throw new Error('Failed to generate key pair');
                        }
                        
                        this.state = {
                            identity: {
                                mnemonic: mnemonic,
                                publicKey: keyPair.publicKey,
                                privateKey: keyPair.privateKey
                            },
                            currentIndex: 0,
                            mempool: [],
                            chain: [],
                            peers: new Set(),
                            theme: 'light'
                        };
                        
                        await this.saveState();
                    }
                    
                    const savedTheme = localStorage.getItem('APStatChainTheme');
                    if (savedTheme) {
                        this.state.theme = savedTheme;
                        if (savedTheme === 'dark') {
                            document.body.classList.add('dark');
                        }
                    }
                    
                    this.audio.context = new (window.AudioContext || window.webkitAudioContext)();
                    this.audio.masterGain = this.audio.context.createGain();
                    this.audio.masterGain.gain.value = 0.7;
                    this.audio.masterGain.connect(this.audio.context.destination);
                    
                    this.ui.bindNavEvents();
                    
                    this.renderer.renderCurrentQuestion();
                    
                } catch (e) {
                    console.error('Initialization failed:', e);
                    alert('Failed to initialize application. Please refresh the page.');
                }
            }
        };

        window.addEventListener('load', () => APStatChain.init());
    </script>
</body>
</html>